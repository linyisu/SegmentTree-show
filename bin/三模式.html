<!DOCTYPE html>
<html lang="zh">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>线段树全方位介绍</title>
  <style>    /* 默认主题 - 白天模式 */
    :root {
      --primary-color: #6c5ce7;
      --secondary-color: #a29bfe;
      --accent-color: #fd79a8;
      --success-bg: linear-gradient(135deg, #00b894, #00cec9);
      --warning-bg: linear-gradient(135deg, #fdcb6e, #e17055);
      --error-bg: linear-gradient(135deg, #fd79a8, #e84393);
      --header-bg: linear-gradient(135deg, #2d3436, #636e72);
      --card-bg: rgba(255, 255, 255, 0.98);
      --card-shadow: 0 20px 40px rgba(0, 0, 0, 0.15);
      --text-primary: #2d3436;
      --text-secondary: #636e72;
      --text-white: #ffffff;
      --body-bg: linear-gradient(135deg, #667eea 0%, #764ba2 50%, #f093fb 100%);
      --nav-bg: rgba(255, 255, 255, 0.98);
      --input-bg: #ffffff;
      --input-border: rgba(108, 92, 231, 0.2);      --input-text: #2d3436;
      --focus-shadow: rgba(108, 92, 231, 0.1);      --footer-text: rgba(255, 255, 255, 0.9);
      --footer-bg: linear-gradient(135deg, rgba(255, 255, 255, 0.1), rgba(255, 255, 255, 0.05));      --code-bg: linear-gradient(135deg, #f8f9fa, #e9ecef);
      --code-text: #495057;
      --nav-button-bg: linear-gradient(135deg, rgba(108, 92, 231, 0.1), rgba(162, 155, 254, 0.1));
      --nav-button-text: #2d3436;
      --nav-button-hover-bg: linear-gradient(135deg, rgba(108, 92, 231, 0.15), rgba(162, 155, 254, 0.15));
      --border-radius: 20px;
      --font-size-base: 14px;
      --line-height-base: 1.6;
    }

    /* 黑夜模式 */
    [data-theme="dark"] {
      --header-bg: linear-gradient(135deg, #1a1a2e, #16213e);
      --card-bg: rgba(26, 26, 46, 0.95);
      --card-shadow: 0 20px 40px rgba(0, 0, 0, 0.4);
      --text-primary: #e2e8f0;
      --text-secondary: #a0aec0;
      --text-white: #ffffff;
      --body-bg: linear-gradient(135deg, #0f0f23 0%, #1a1a2e 50%, #16213e 100%);
      --nav-bg: rgba(26, 26, 46, 0.95);
      --input-bg: rgba(45, 55, 72, 0.9);
      --input-border: rgba(108, 92, 231, 0.4);      --input-text: #e2e8f0;
      --focus-shadow: rgba(108, 92, 231, 0.2);      --footer-text: rgba(226, 232, 240, 0.9);
      --footer-bg: linear-gradient(135deg, rgba(26, 26, 46, 0.3), rgba(22, 33, 62, 0.2));      --code-bg: linear-gradient(135deg, #1a1a2e, #16213e);
      --code-text: #e2e8f0;
      --nav-button-bg: linear-gradient(135deg, rgba(26, 26, 46, 0.8), rgba(22, 33, 62, 0.6));
      --nav-button-text: #a0aec0;
      --nav-button-hover-bg: linear-gradient(135deg, rgba(26, 26, 46, 0.9), rgba(22, 33, 62, 0.8));
    }

    /* 护眼模式 */
    [data-theme="eye-care"] {
      --primary-color: #4a5568;
      --secondary-color: #718096;
      --accent-color: #68d391;
      --header-bg: linear-gradient(135deg, #2d3748, #4a5568);
      --card-bg: rgba(237, 242, 247, 0.98);
      --card-shadow: 0 20px 40px rgba(0, 0, 0, 0.1);
      --text-primary: #2d3748;
      --text-secondary: #4a5568;
      --text-white: #ffffff;
      --body-bg: linear-gradient(135deg, #e6fffa 0%, #f0fff4 50%, #f7fafc 100%);
      --nav-bg: rgba(237, 242, 247, 0.98);
      --input-bg: rgba(255, 255, 255, 0.9);
      --input-border: rgba(74, 85, 104, 0.3);      --input-text: #2d3748;
      --focus-shadow: rgba(74, 85, 104, 0.15);      --footer-text: rgba(45, 55, 72, 0.8);
      --footer-bg: linear-gradient(135deg, rgba(237, 242, 247, 0.4), rgba(237, 242, 247, 0.2));      --code-bg: linear-gradient(135deg, #f0f9ff, #e0f2fe);
      --code-text: #0f172a;
      --nav-button-bg: linear-gradient(135deg, rgba(237, 242, 247, 0.8), rgba(237, 242, 247, 0.6));
      --nav-button-text: #4a5568;
      --nav-button-hover-bg: linear-gradient(135deg, rgba(237, 242, 247, 0.9), rgba(237, 242, 247, 0.8));
    }body {
      margin: 0;
      font-family: 'Inter', 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
      display: flex;
      height: 100vh;
      overflow: hidden;
      background: var(--body-bg);
      min-width: 800px;
      position: relative;
      transition: all 0.3s ease;
    }
    body::before {
      content: '';
      position: fixed;
      top: 0;
      left: 0;
      width: 100%;
      height: 100%;
      background: 
        radial-gradient(circle at 20% 80%, rgba(120, 119, 198, 0.3) 0%, transparent 50%),
        radial-gradient(circle at 80% 20%, rgba(255, 119, 198, 0.3) 0%, transparent 50%),
        radial-gradient(circle at 40% 40%, rgba(120, 219, 255, 0.2) 0%, transparent 50%);
      z-index: -1;
    }      header {
      position: fixed;
      top: 0;
      width: 100%;
      background: var(--header-bg);
      color: var(--text-white);
      padding: 20px;
      text-align: center;
      font-size: 32px;
      font-weight: 700;
      z-index: 1000;
      box-shadow: 0 8px 32px rgba(0, 0, 0, 0.25);
      backdrop-filter: blur(20px);
      border-bottom: 1px solid rgba(255, 255, 255, 0.2);
      letter-spacing: 1px;
      background-attachment: fixed;
    }
    header::after {
      content: '';
      position: absolute;
      bottom: 0;
      left: 50%;
      transform: translateX(-50%);
      width: 100px;
      height: 3px;
      background: linear-gradient(90deg, var(--primary-color), var(--accent-color));
      border-radius: 2px;
    }      nav {
      margin-top: 85px;
      width: 280px;
      min-width: 280px;
      max-width: 280px;
      flex-shrink: 0;
      background: var(--nav-bg);
      backdrop-filter: blur(20px);
      padding: 25px;
      box-shadow: 4px 0 30px rgba(0, 0, 0, 0.12);
      overflow-y: auto;
      border-radius: 0 var(--border-radius) var(--border-radius) 0;
      box-sizing: border-box;
      border-right: 1px solid rgba(255, 255, 255, 0.3);
      transition: all 0.3s ease;
    }    .btn {
      padding: 12px 24px;
      background: linear-gradient(135deg, var(--primary-color), var(--secondary-color));
      color: var(--text-white);
      border: none;
      border-radius: 12px;
      cursor: pointer;
      font-weight: 600;
      font-size: 14px;
      transition: all 0.4s cubic-bezier(0.175, 0.885, 0.32, 1.275);
      position: relative;
      overflow: hidden;
      text-transform: none;
      letter-spacing: 0.5px;
    }
    .btn::before {
      content: '';
      position: absolute;
      top: 0;
      left: -100%;
      width: 100%;
      height: 100%;
      background: linear-gradient(90deg, transparent, rgba(255, 255, 255, 0.2), transparent);
      transition: left 0.5s;
    }
    .btn:hover {
      transform: translateY(-3px) scale(1.02);
      box-shadow: 0 8px 25px rgba(108, 92, 231, 0.4);
    }
    .btn:hover::before {
      left: 100%;
    }
    .btn:active {
      transform: translateY(-1px) scale(0.98);
    }    nav button {
      display: block;
      width: 100%;
      min-width: 220px;
      margin: 15px 0;
      padding: 16px 20px;
      text-align: left;
      font-size: 15px;
      white-space: nowrap;
      overflow: hidden;
      text-overflow: ellipsis;
      border-radius: 15px;
      position: relative;
      transition: all 0.3s cubic-bezier(0.4, 0, 0.2, 1);
      background: var(--nav-button-bg);
      color: var(--nav-button-text);
      border: 2px solid transparent;
    }
    nav button::before {
      content: '';
      position: absolute;
      left: 0;
      top: 0;
      height: 100%;
      width: 4px;
      background: var(--primary-color);
      transform: scaleY(0);
      transition: transform 0.3s ease;
      border-radius: 0 2px 2px 0;
    }    nav button:hover {
      background: var(--nav-button-hover-bg);
      transform: translateX(5px);
      border-color: rgba(108, 92, 231, 0.3);
    }
    nav button:hover::before {
      transform: scaleY(1);
    }    nav button.active {
      background: var(--success-bg);
      color: var(--text-white);
      box-shadow: 0 8px 20px rgba(0, 184, 148, 0.3);
      border-color: rgba(255, 255, 255, 0.3);
    }
    nav button.active::before {
      background: rgba(255, 255, 255, 0.8);
      transform: scaleY(1);
    }   
    main {
      flex-grow: 1;
      margin-top: 85px;
      padding: 30px;
      overflow-y: auto;
      background: rgba(255, 255, 255, 0.05);
      position: relative;
    }
    main::before {
      content: '';
      position: absolute;
      top: 0;
      left: 0;
      right: 0;
      bottom: 0;
      background: 
        radial-gradient(circle at 70% 30%, rgba(255, 255, 255, 0.1) 0%, transparent 50%),
        radial-gradient(circle at 30% 70%, rgba(255, 255, 255, 0.05) 0%, transparent 50%);
      pointer-events: none;
      z-index: 0;
    }
    main > * {
      position: relative;
      z-index: 1;
    }
    section {
      display: none;
    }
    section.active {
      display: block;
    }
    .card {
      background: var(--card-bg);
      backdrop-filter: blur(20px);
      padding: 35px;
      border-radius: var(--border-radius);
      box-shadow: var(--card-shadow);
      margin-bottom: 30px;
      border: 1px solid rgba(255, 255, 255, 0.2);
      position: relative;
      overflow: hidden;
    }
    .card::before {
      content: '';
      position: absolute;
      top: 0;
      left: 0;
      right: 0;
      height: 4px;
      background: linear-gradient(90deg, var(--primary-color), var(--accent-color), var(--secondary-color));
    }
    .card h2 {
      color: var(--text-primary);
      margin-bottom: 25px;
      font-size: 28px;
      font-weight: 700;
      background: linear-gradient(135deg, var(--primary-color), var(--accent-color));
      -webkit-background-clip: text;
      -webkit-text-fill-color: transparent;
      background-clip: text;
      position: relative;
    }
    .card h3 {
      color: var(--text-secondary);
      margin: 25px 0 18px 0;
      font-size: 20px;
      font-weight: 600;
      position: relative;
      padding-left: 20px;
    }
    .card h3::before {
      content: '';
      position: absolute;
      left: 0;
      top: 50%;
      transform: translateY(-50%);
      width: 4px;
      height: 20px;
      background: linear-gradient(135deg, var(--primary-color), var(--accent-color));
      border-radius: 2px;
    }
    .card p {
      line-height: 1.9;
      color: var(--text-primary);
      margin-bottom: 18px;
      font-size: 16px;
      font-weight: 400;
    }    .code-block {
      background: var(--code-bg);
      color: var(--code-text);
      padding: 25px;
      border-radius: 16px;
      margin: 25px 0;
      overflow-x: auto;
      font-family: 'JetBrains Mono', 'Fira Code', 'Courier New', monospace;
      font-size: var(--font-size-base);
      line-height: var(--line-height-base);
      box-shadow: 
        inset 0 1px 0 rgba(255, 255, 255, 0.1),
        0 10px 30px rgba(0, 0, 0, 0.3);
      white-space: pre-wrap;
      word-wrap: break-word;
      position: relative;      border: 1px solid rgba(255, 255, 255, 0.1);
    }
    .code-block code {
      display: block;
      width: 100%;
      height: 100%;
      font-family: inherit;
      font-size: inherit;
      line-height: inherit;
      color: inherit;
      background: transparent;
      border: none;
      padding: 0;
      margin: 0;
      white-space: inherit;
      word-wrap: inherit;
    }
    .code-block::before {
      content: '';
      position: absolute;
      top: 0;
      left: 0;
      right: 0;
      height: 3px;
      background: linear-gradient(90deg, var(--primary-color), var(--accent-color));
      border-radius: 16px 16px 0 0;
    }
    .code-block::after {
      content: '{ }';
      position: absolute;
      top: 15px;
      right: 20px;
      color: rgba(255, 255, 255, 0.3);
      font-size: 18px;
      font-weight: bold;    }    
    /* 语法高亮样式 - 确保在 pre > code 结构中正常工作 */
    .code-block .keyword, .code-block code .keyword { color: #63b3ed; font-weight: bold; }
    .code-block .type, .code-block code .type { color: #68d391; font-weight: bold; }
    .code-block .function, .code-block code .function { color: #fbb6ce; }
    .code-block .number, .code-block code .number { color: #f6ad55; }
    .code-block .comment, .code-block code .comment { color: #a0aec0; font-style: italic; }
    .code-block .string, .code-block code .string { color: #9ae6b4; }
    .code-block .operator, .code-block code .operator { color: #fbb6ce; font-weight: bold; }
    .code-block .variable, .code-block code .variable { color: #e9c46a; font-weight: 500; }
    .code-block .bracket, .code-block code .bracket { color: #ff6b6b; font-weight: bold; }
    .code-block .symbol, .code-block code .symbol { color: #4ecdc4; font-weight: 500; }
    .code-block .pointer, .code-block code .pointer { color: #ff8a65; font-weight: bold; }
    .code-block .preprocessor, .code-block code .preprocessor { color: #ba68c8; font-weight: bold; }
    .code-block .constant, .code-block code .constant { color: #ffd93d; font-weight: bold; }    .code-block .namespace, .code-block code .namespace { color: #a78bfa; font-weight: 600; }
    
    /* 白天模式语法高亮 - 使用更柔和的颜色 */
    [data-theme="light"] .code-block .function,
    [data-theme="light"] .code-block code .function { color: #5a67d8; }
    [data-theme="light"] .code-block .variable,
    [data-theme="light"] .code-block code .variable { color: #c05621; font-weight: 500; }
    [data-theme="light"] .code-block .keyword,
    [data-theme="light"] .code-block code .keyword { color: #d53f8c; font-weight: bold; }
    [data-theme="light"] .code-block .type,
    [data-theme="light"] .code-block code .type { color: #38a169; font-weight: bold; }
    [data-theme="light"] .code-block .string,
    [data-theme="light"] .code-block code .string { color: #38a169; }
    [data-theme="light"] .code-block .comment,
    [data-theme="light"] .code-block code .comment { color: #718096; font-style: italic; }
    [data-theme="light"] .code-block .number,
    [data-theme="light"] .code-block code .number { color: #d53f8c; }
    [data-theme="light"] .code-block .operator,
    [data-theme="light"] .code-block code .operator { color: #d53f8c; font-weight: bold; }
    [data-theme="light"] .code-block .bracket,
    [data-theme="light"] .code-block code .bracket { color: #d53f8c; font-weight: bold; }
    [data-theme="light"] .code-block .symbol,
    [data-theme="light"] .code-block code .symbol { color: #5a67d8; font-weight: 500; }
    [data-theme="light"] .code-block .pointer,
    [data-theme="light"] .code-block code .pointer { color: #c05621; font-weight: bold; }
    [data-theme="light"] .code-block .preprocessor,
    [data-theme="light"] .code-block code .preprocessor { color: #5a67d8; font-weight: bold; }
    [data-theme="light"] .code-block .constant,
    [data-theme="light"] .code-block code .constant { color: #38a169; font-weight: bold; }
    [data-theme="light"] .code-block .namespace,
    [data-theme="light"] .code-block code .namespace { color: #5a67d8; font-weight: 600; }

    /* 护眼模式语法高亮 - 使用更柔和的颜色 */
    [data-theme="eye-care"] .code-block .function,
    [data-theme="eye-care"] .code-block code .function { color: #4c51bf; }
    [data-theme="eye-care"] .code-block .variable,
    [data-theme="eye-care"] .code-block code .variable { color: #9c4221; font-weight: 500; }
    [data-theme="eye-care"] .code-block .keyword,
    [data-theme="eye-care"] .code-block code .keyword { color: #38a169; font-weight: bold; }
    [data-theme="eye-care"] .code-block .type,
    [data-theme="eye-care"] .code-block code .type { color: #319795; font-weight: bold; }
    [data-theme="eye-care"] .code-block .string,
    [data-theme="eye-care"] .code-block code .string { color: #38a169; }
    [data-theme="eye-care"] .code-block .comment,
    [data-theme="eye-care"] .code-block code .comment { color: #718096; font-style: italic; }
    [data-theme="eye-care"] .code-block .number,
    [data-theme="eye-care"] .code-block code .number { color: #e53e3e; }
    [data-theme="eye-care"] .code-block .operator,
    [data-theme="eye-care"] .code-block code .operator { color: #e53e3e; font-weight: bold; }
    [data-theme="eye-care"] .code-block .bracket,
    [data-theme="eye-care"] .code-block code .bracket { color: #e53e3e; font-weight: bold; }
    [data-theme="eye-care"] .code-block .symbol,
    [data-theme="eye-care"] .code-block code .symbol { color: #319795; font-weight: 500; }
    [data-theme="eye-care"] .code-block .pointer,
    [data-theme="eye-care"] .code-block code .pointer { color: #9c4221; font-weight: bold; }
    [data-theme="eye-care"] .code-block .preprocessor,
    [data-theme="eye-care"] .code-block code .preprocessor { color: #4c51bf; font-weight: bold; }
    [data-theme="eye-care"] .code-block .constant,
    [data-theme="eye-care"] .code-block code .constant { color: #319795; font-weight: bold; }
    [data-theme="eye-care"] .code-block .namespace,
    [data-theme="eye-care"] .code-block code .namespace { color: #4c51bf; font-weight: 600; }
    
    .settings-panel {
      background: var(--card-bg);
      padding: 25px;
      border-radius: 18px;
      margin-bottom: 25px;
      border: 2px solid rgba(108, 92, 231, 0.2);
      box-shadow: 0 8px 25px rgba(0, 0, 0, 0.1);
      position: relative;
      overflow: hidden;
    }
    .settings-panel::before {
      content: '';
      position: absolute;
      top: 0;
      left: 0;
      right: 0;
      height: 3px;
      background: linear-gradient(90deg, var(--primary-color), var(--accent-color));
    }
    .settings-row {
      display: flex;
      align-items: center;
      margin: 18px 0;
      gap: 18px;
    }
    .settings-row label {
      font-weight: 600;
      color: var(--text-primary);
      min-width: 140px;
      font-size: 15px;
    }    .settings-row input, .settings-row select {
      padding: 12px 16px;
      border: 2px solid var(--input-border);
      border-radius: 12px;
      background: var(--input-bg);
      color: var(--input-text);
      transition: all 0.3s ease;
      font-size: 14px;
    }    .settings-row input:focus, .settings-row select:focus {
      outline: none;
      border-color: var(--primary-color);
      box-shadow: 0 0 0 3px var(--focus-shadow);
      transform: translateY(-1px);
    }
    #tree-container {
      margin-top: 30px;
      padding: 25px;
      background: var(--card-bg);
      border-radius: 18px;
      border-left: 5px solid var(--primary-color);
      box-shadow: 0 8px 25px rgba(0, 0, 0, 0.1);
      position: relative;
      overflow: visible;
      min-height: 200px; /* 降低最小高度 */
    }
    #tree-container::before {
      content: '';
      position: absolute;
      top: 0;
      right: 0;
      width: 100px;
      height: 100px;
      background: radial-gradient(circle, rgba(108, 92, 231, 0.1) 0%, transparent 70%);
      border-radius: 50%;
    }
    
    #tree-container h4 {
      text-align: center;
      color: var(--primary-color);
      margin-bottom: 20px;
      font-size: 18px;
      font-weight: 600;
    }
    
    #tree-container p {
      text-align: center;
      margin-bottom: 25px;
      padding: 10px;
      background: rgba(108, 92, 231, 0.1);
      border-radius: 8px;
      border-left: 3px solid var(--primary-color);
    }    /* 真正的树形可视化样式 */    
    .tree-visual {
      width: 100%; /* 改为100%自适应宽度 */
      overflow: hidden; /* 确保内容不溢出 */
      padding: 30px 25px; /* 增加上下内边距，左右保持25px */
      position: relative;
      box-sizing: border-box; /* 包含padding在宽度计算内 */
      min-height: 400px; /* 增加最小高度 */
    }
    .tree-level {
      display: flex;
      justify-content: space-between;
      align-items: center;
      margin: 18px 0;
      position: relative;
      width: 100%;
      padding: 0;
      min-height: 50px;
    }
    
    .tree-level-0, .tree-level-1, .tree-level-2, .tree-level-3 {
      margin: 18px 0;
      display: flex;
      width: 100%;
    }    .tree-node {
      background: linear-gradient(135deg, var(--primary-color), var(--secondary-color));
      color: var(--text-white);
      padding: 8px 12px;
      border-radius: 8px;
      display: flex;
      align-items: center;
      justify-content: center;
      text-align: center;
      height: 35px;
      font-weight: 600;
      box-shadow: 0 4px 12px rgba(108, 92, 231, 0.3);
      transition: all 0.3s cubic-bezier(0.4, 0, 0.2, 1);
      position: absolute;
      overflow: hidden;
      border: 1px solid rgba(255, 255, 255, 0.3);
      word-wrap: break-word;
      font-size: 10px;
      line-height: 1.2;
      z-index: 2;
      backdrop-filter: blur(3px);
      white-space: pre-line;
      box-sizing: border-box;
    }
    .tree-node.depth-0 {
      background: linear-gradient(135deg, #6c5ce7, #a29bfe);
      height: 40px;
      font-size: 11px;
      font-weight: 700;
      box-shadow: 0 6px 16px rgba(108, 92, 231, 0.4);
    }
    
    .tree-node.depth-1 {
      background: linear-gradient(135deg, #fd79a8, #e84393);
      height: 35px;
      font-size: 10px;
      box-shadow: 0 5px 14px rgba(253, 121, 168, 0.3);
    }
    
    .tree-node.depth-2 {
      background: linear-gradient(135deg, #00b894, #00cec9);
      height: 35px;
      font-size: 10px;
      box-shadow: 0 4px 12px rgba(0, 184, 148, 0.3);
    }
    
    .tree-node.depth-3 {
      background: linear-gradient(135deg, #fdcb6e, #e17055);
      height: 35px;
      font-size: 9px;
      box-shadow: 0 3px 10px rgba(253, 203, 110, 0.3);
    }
    /* 连接线样式 */
    .tree-connection {
      position: absolute;
      background: linear-gradient(135deg, var(--primary-color), var(--secondary-color));
      z-index: 1;
    }
    
    .tree-connection.vertical {
      width: 2px;
      top: -25px;
      height: 25px;
    }
    
    .tree-connection.horizontal {
      height: 2px;
      top: -25px;
    }
    
    .tree-connection-line {
      opacity: 0;
      animation: fadeInLine 0.5s ease-in-out 0.3s forwards;
    }
    @keyframes fadeInLine {
      from {
        opacity: 0;
      }
      to {
        opacity: 1;
      }
    }
    
    .tree-node::before {
      content: '';
      position: absolute;
      top: 0;
      left: -100%;
      width: 100%;
      height: 100%;
      background: linear-gradient(90deg, transparent, rgba(255, 255, 255, 0.3), transparent);
      transition: left 0.6s ease;
    }
    
    .tree-node:hover::before {
      left: 100%;
    }
    .tree-node:hover {
      transform: translateY(-3px);
      box-shadow: 0 8px 20px rgba(0, 0, 0, 0.3);
      z-index: 10;
    }
    
    /* 简化的节点出现动画 - 只改变透明度和轻微位移 */
    .tree-node {
      transition: all 0.3s cubic-bezier(0.4, 0, 0.2, 1);
    }
    .quiz-question {
      margin: 25px 0;
      padding: 25px;
      background: linear-gradient(135deg, rgba(108, 92, 231, 0.1), rgba(162, 155, 254, 0.05));
      border-radius: 16px;
      border-left: 5px solid var(--primary-color);
      box-shadow: 0 8px 25px rgba(0, 0, 0, 0.08);
      position: relative;
      overflow: hidden;
    }
    .quiz-question::before {
      content: '';
      position: absolute;
      top: 0;
      right: 0;
      width: 60px;
      height: 60px;
      background: radial-gradient(circle, rgba(108, 92, 231, 0.15) 0%, transparent 70%);
      border-radius: 50%;
    }
    .quiz-options label {
      display: block;
      margin: 6px 0;
      cursor: pointer;
      padding: 10px 14px;
      border-radius: 10px;
      transition: all 0.3s ease;
      border: 2px solid transparent;
      background: rgba(255, 255, 255, 0.5);
      position: relative;
      overflow: hidden;
    }
    .quiz-options label::before {
      content: '';
      position: absolute;
      left: 0;
      top: 0;
      height: 100%;
      width: 4px;
      background: var(--primary-color);
      transform: scaleY(0);
      transition: transform 0.3s ease;
    }
    .quiz-options label:hover {
      background: rgba(108, 92, 231, 0.1);
      border-color: rgba(108, 92, 231, 0.3);
      transform: translateX(5px);
    }
    .quiz-options label:hover::before {
      transform: scaleY(1);
    }
    .quiz-result {
      margin-top: 25px;
      padding: 20px;
      border-radius: 16px;
      display: none;
      box-shadow: 0 8px 25px rgba(0, 0, 0, 0.15);
      border: 1px solid rgba(255, 255, 255, 0.2);
    }    footer {
      margin-top: 50px;
      font-size: 15px;
      color: var(--footer-text);
      text-align: center;
      padding: 25px;
      background: var(--footer-bg);
      border-radius: 18px;
      backdrop-filter: blur(10px);
      border: 1px solid rgba(255, 255, 255, 0.2);
      box-shadow: 0 8px 25px rgba(0, 0, 0, 0.1);
    }
    /* 添加滚动条美化 */
    ::-webkit-scrollbar {
      width: 8px;
    }
    ::-webkit-scrollbar-track {
      background: rgba(255, 255, 255, 0.1);
      border-radius: 4px;
    }
    ::-webkit-scrollbar-thumb {
      background: linear-gradient(135deg, var(--primary-color), var(--secondary-color));
      border-radius: 4px;
    }
    ::-webkit-scrollbar-thumb:hover {
      background: linear-gradient(135deg, var(--secondary-color), var(--primary-color));
    }
    /* 添加焦点样式 */
    .btn:focus,
    nav button:focus,
    input:focus,
    select:focus {
      outline: 2px solid var(--primary-color);
      outline-offset: 2px;
    }    /* 添加响应式优化 */
    @media (max-width: 1200px) {
      nav {
        width: 250px;
        min-width: 250px;
        max-width: 250px;
      }
      nav button {
        min-width: 200px;
        font-size: 14px;
        padding: 14px 18px;
      }
      .card h2 {
        font-size: 24px;
      }
      .card h3 {
        font-size: 18px;
      }
    .tree-visual {
        width: 100%;
        overflow: hidden;
        padding: 30px 25px;
        position: relative;
        box-sizing: border-box;
        min-height: 200px; /* 降低最小高度 */
      }
    }

    /* 三级主题开关样式 */
    .theme-switcher {
      position: fixed;
      top: 20px;
      right: 20px;
      z-index: 10000;
      background: var(--card-bg);
      backdrop-filter: blur(20px);
      border-radius: 25px;
      padding: 8px;
      box-shadow: var(--card-shadow);
      border: 1px solid rgba(255, 255, 255, 0.2);
      display: flex;
      align-items: center;
      gap: 0;
      transition: all 0.3s ease;
    }

    .theme-option {
      width: 40px;
      height: 40px;
      border-radius: 20px;
      border: none;
      cursor: pointer;
      transition: all 0.3s ease;
      display: flex;
      align-items: center;
      justify-content: center;
      font-size: 18px;
      position: relative;
      background: transparent;
    }

    .theme-option:hover {
      transform: scale(1.1);
    }    .theme-option.active {
      background: var(--primary-color);
      color: var(--text-white);
      transform: scale(1.2);
      box-shadow: 0 4px 15px rgba(108, 92, 231, 0.4);
    }

    .theme-option[data-theme="light"] {
      background: linear-gradient(135deg, #ffd93d, #ff9a56);
    }

    .theme-option[data-theme="dark"] {
      background: linear-gradient(135deg, #2d3748, #4a5568);
      color: #e2e8f0;
    }    .theme-option[data-theme="eye-care"] {
      background: linear-gradient(135deg, #68d391, #38b2ac);
      color: var(--text-white);
    }

    .theme-option.active[data-theme="light"] {
      background: linear-gradient(135deg, #ffd93d, #ff9a56);
      color: #2d3436;
    }

    .theme-option.active[data-theme="dark"] {
      background: linear-gradient(135deg, #2d3748, #4a5568);
      color: #e2e8f0;
    }

    .theme-option.active[data-theme="eye-care"] {
      background: linear-gradient(135deg, #68d391, #38b2ac);
      color: #2d3748;
    }
  </style>
</head>
<body>
  <!-- 三级主题开关 -->
  <div class="theme-switcher">
    <button class="theme-option active" data-theme="light" onclick="switchTheme('light')" title="白天模式">☀️</button>
    <button class="theme-option" data-theme="dark" onclick="switchTheme('dark')" title="黑夜模式">🌙</button>
    <button class="theme-option" data-theme="eye-care" onclick="switchTheme('eye-care')" title="护眼模式">🌿</button>
  </div>

  <header>🌲 线段树全方位介绍（从入门到入土）</header>

  <nav>
    <button class="nav-btn active" onclick="showSection('intro')" aria-label="线段树简介">📚 线段树简介</button>
    <button class="nav-btn" onclick="showSection('basic')" aria-label="基本操作">🔧 基本操作</button>
    <button class="nav-btn" onclick="showSection('advanced')" aria-label="高级技巧">🚀 高级技巧</button>
    <button class="nav-btn" onclick="showSection('quiz')" aria-label="互动测试">🎯 互动测试</button>
    <button class="nav-btn" onclick="showSection('settings')" aria-label="自定义设置">⚙️ 自定义设置</button>
  </nav>

  <main>
    <section id="intro" class="active">
      <div class="card">
        <h2>🌳 什么是线段树？</h2>
        <p>线段树(Segment Tree)是一个能够高效处理区间查询和更新的数据结构，时间复杂度为<strong>O(log n)</strong>，适用于静态或动态数组。</p>
        <p>它以二叉树的形式递归划分区间，直到每个段表示单个元素，每个节点表示一个区间。</p>
        <h3>📊 线段树可维护的区间信息</h3>
        <p>• <strong>区间和</strong>：计算区间内所有元素的总和</p>
        <p>• <strong>区间最值(RMQ)</strong>：查询区间内的最大值或最小值</p>
        <p>• <strong>区间GCD</strong>：计算区间内所有数的最大公约数</p>
        <p>• <strong>区间最大子段和</strong>：寻找区间内连续子数组的最大和</p>
        <p>• <strong>区间最长连续相同值段</strong>：统计相同值的最长连续长度</p>
        <p>• <strong>区间最长递增/递减段</strong>：寻找最长的单调序列</p>
        <p>• <strong>……</strong></p>
        <h3>⚡ 线段树支持的区间修改操作</h3>
        <p>• <strong>区间加法</strong>：给区间内所有元素加上某个值</p>
        <p>• <strong>区间乘法</strong>：给区间内所有元素乘以某个值</p>
        <p>• <strong>区间赋值</strong>：将区间内所有元素设为某个值</p>
        <p>• <strong>区间异或</strong>：对区间内所有元素进行异或操作</p>
        <p>• <strong>区间取反</strong>：对区间内所有元素取反</p>
        <p>• <strong>区间拼接</strong>：连接多个区间</p>
        <p>• <strong>……</strong></p>
      </div>
    </section>

    <section id="basic">
      <div class="card">
        <h2>🔧 线段树的构建与操作</h2>
        <p>线段树的构建通常采用递归方式，根据区间不断对半划分，每个节点编号 <code>u</code> 表示当前处理的区间 <code>[l, r]</code>。</p>
        <h3>📝 构建函数详解</h3>
        <pre class="code-block" id="build-code"><code>void build(int l, int r, int u)
{
    if (l == r)
    {
        info[u] = Info(arr[l]);
        return;
    }
    
    int mid = (l + r) >> 1;
    build(l, mid, u << 1);
    build(mid + 1, r, u << 1 | 1);
    push_up(u);
}</code></pre>
        <h3>🎯 构建过程可视化</h3>
        <div class="settings-row">
          <label>数组长度 n:</label>
          <input type="number" id="input-n" value="8" min="1" max="8" aria-label="输入数组长度" />
          <button class="btn" id="btn-build" aria-label="开始构建线段树">🚀 开始构建</button>
        </div>
        <div id="tree-container">
          <p>点击"开始构建"按钮查看线段树构建过程</p>
        </div>
        <h3>📚 其他核心操作</h3>
        <pre class="code-block"><code>// 区间查询
Info query(int l, int r, int ql, int qr, int u)
{
    if (ql <= l && r <= qr)
        return info[u];
    
    int mid = (l + r) >> 1;
    Info res;
    if (ql <= mid)
        res = res + query(l, mid, ql, qr, u << 1);
    if (qr > mid)
        res = res + query(mid + 1, r, ql, qr, u << 1 | 1);
    return res;
}

// 单点更新
void update(int l, int r, int pos, int val, int u)
{
    if (l == r)
    {
        info[u] = Info(val);
        return;
    }
    
    int mid = (l + r) >> 1;
    if (pos <= mid)
        update(l, mid, pos, val, u << 1);
    else
        update(mid + 1, r, pos, val, u << 1 | 1);
    push_up(u);
}</code></pre>
      </div>
    </section>

    <section id="advanced">
      <div class="card">
        <h2>🚀 进阶技巧</h2>        <h3>⏰ 懒惰标记 (Lazy Propagation)</h3>
        <p>懒惰标记是线段树的重要优化技术，用于处理区间修改操作，避免每次都递归到叶子节点。</p>
        <pre class="code-block"><code>void push_down(int u, int l, int r)
{
    if (lazy[u] != 0)
    {
        int mid = (l + r) >> 1;
        lazy[u << 1] += lazy[u];
        lazy[u << 1 | 1] += lazy[u];
        info[u << 1].sum += lazy[u] * (mid - l + 1);
        info[u << 1 | 1].sum += lazy[u] * (r - mid);
        lazy[u] = 0;
    }
}

// 区间修改
void modify(int l, int r, int ql, int qr, int val, int u)
{
    if (ql <= l && r <= qr)
    {
        lazy[u] += val;
        info[u].sum += val * (r - l + 1);
        return;
    }
    
    push_down(u, l, r);
    int mid = (l + r) >> 1;
    if (ql <= mid)
        modify(l, mid, ql, qr, val, u << 1);
    if (qr > mid)
        modify(mid + 1, r, ql, qr, val, u << 1 | 1);
    push_up(u);
}</code></pre>        <h3>🌍 可持久化线段树</h3>
        <p>可持久化线段树能够保存数据结构的历史版本，支持查询任意历史时刻的状态。</p>
        <pre class="code-block"><code>struct Node
{
    int sum, lc, rc;
} tree[MAXN];

int tot = 0;

int build(int l, int r)
{
    int u = ++tot;
    if (l == r)
    {
        tree[u].sum = a[l];
        return u;
    }
    
    int mid = (l + r) >> 1;
    tree[u].lc = build(l, mid);
    tree[u].rc = build(mid + 1, r);
    tree[u].sum = tree[tree[u].lc].sum + tree[tree[u].rc].sum;
    return u;
}

int update(int pre, int l, int r, int pos, int val)
{
    int u = ++tot;
    tree[u] = tree[pre];
    if (l == r)
    {
        tree[u].sum += val;
        return u;
    }
    
    int mid = (l + r) >> 1;
    if (pos <= mid)
        tree[u].lc = update(tree[pre].lc, l, mid, pos, val);
    else
        tree[u].rc = update(tree[pre].rc, mid + 1, r, pos, val);
    tree[u].sum = tree[tree[u].lc].sum + tree[tree[u].rc].sum;
    return u;
}</code></pre>        <h3>⚖️ 权值线段树</h3>
        <p>权值线段树以值域作为下标建树，常用于处理第k小数、数值统计等问题。</p>
        <pre class="code-block"><code>
// 插入一个数值
void insert(int l, int r, int val, int u)
{
    tree[u]++;
    if (l == r)
        return;
        
    int mid = (l + r) >> 1;
    if (val <= mid)
        insert(l, mid, val, u << 1);
    else
        insert(mid + 1, r, val, u << 1 | 1);
}

// 查询第k小的数
int kth(int l, int r, int k, int u)
{
    if (l == r)
        return l;
        
    int mid = (l + r) >> 1;
    if (tree[u << 1] >= k)
        return kth(l, mid, k, u << 1);
    else
        return kth(mid + 1, r, k - tree[u << 1], u << 1 | 1);
}</code></pre>
      </div>
    </section>

    <section id="quiz">
      <div class="card">
        <h2>🎯 互动小测</h2>
        <p>通过以下选择题测试你对线段树的理解程度！</p>
        <div id="quiz-container">
          <div class="quiz-question">
            <h3>问题 1: 线段树的单次区间操作的时间复杂度是？</h3>
            <div class="quiz-options">
              <label><input type="radio" name="q1" value="a" aria-label="选项A: O(n)"> A. O(n)</label><br>
              <label><input type="radio" name="q1" value="b" aria-label="选项B: O(log n)"> B. O(log n)</label><br>
              <label><input type="radio" name="q1" value="c" aria-label="选项C: O(n log n)"> C. O(n log n)</label><br>
              <label><input type="radio" name="q1" value="d" aria-label="选项D: O(n²)"> D. O(n²)</label>
            </div>
          </div>
          <div class="quiz-question">
            <h3>问题 2: 线段树的空间复杂度通常是？</h3>
            <div class="quiz-options">
              <label><input type="radio" name="q2" value="a" aria-label="选项A: O(n)"> A. O(n)</label><br>
              <label><input type="radio" name="q2" value="b" aria-label="选项B: O(2n)"> B. O(2n)</label><br>
              <label><input type="radio" name="q2" value="c" aria-label="选项C: O(4n)"> C. O(4n)</label><br>
              <label><input type="radio" name="q2" value="d" aria-label="选项D: O(n log n)"> D. O(n log n)</label>
            </div>
          </div>
          <div class="quiz-question">
            <h3>问题 3: 懒惰标记的主要作用是？</h3>
            <div class="quiz-options">
              <label><input type="radio" name="q3" value="a" aria-label="选项A: 减少内存使用"> A. 减少内存使用</label><br>
              <label><input type="radio" name="q3" value="b" aria-label="选项B: 优化区间修改操作"> B. 优化区间修改操作</label><br>
              <label><input type="radio" name="q3" value="c" aria-label="选项C: 简化代码实现"> C. 简化代码实现</label><br>
              <label><input type="radio" name="q3" value="d" aria-label="选项D: 提高查询速度"> D. 提高查询速度</label>
            </div>
          </div>
          <button class="btn" onclick="checkQuiz()" aria-label="提交测试答案">📊 提交答案</button>
          <div id="quiz-result" class="quiz-result"></div>
        </div>
      </div>
    </section>    <section id="settings">
      <div class="card">
        <h2>⚙️ 自定义设置</h2>
        
        <div class="settings-panel">
          <h3>🎨 主题切换</h3>
          <p>在页面右上角可以看到三个主题切换按钮：</p>
          <p>• <strong>☀️ 白天模式</strong>：明亮清晰，适合白天使用</p>
          <p>• <strong>🌙 黑夜模式</strong>：深色背景，减少眼部疲劳</p>
          <p>• <strong>🌿 护眼模式</strong>：护眼配色，长时间阅读更舒适</p>
        </div>
        
        <div class="settings-panel">
          <h3>🎨 代码显示设置</h3>
          <div class="settings-row">
            <label>字体大小:</label>
            <input type="range" id="font-size-slider" min="12" max="20" value="14" aria-label="调整代码字体大小">
            <span id="font-size-display">14px</span>
          </div>
          <div class="settings-row">
            <label>行高:</label>
            <input type="range" id="line-height-slider" min="1.2" max="2.0" step="0.1" value="1.6" aria-label="调整代码行高">
            <span id="line-height-display">1.6</span>
          </div>
        </div>
        <div class="settings-panel">
          <h3>🌲 可视化设置</h3>
          <div class="settings-row">
            <label>动画速度:</label>
            <select id="animation-speed" aria-label="选择动画速度">
              <option value="slow">🐌 慢速 (2秒)</option>
              <option value="normal">🚀 正常 (1秒)</option>
              <option value="fast" selected>⚡ 快速 (0.5秒)</option>
            </select>
          </div>
          <div class="settings-row">
            <label>节点颜色:</label>
            <input type="color" id="node-color" value="#74b9ff" aria-label="选择节点颜色">
            <button class="btn" onclick="applyNodeColor()" aria-label="应用节点颜色">应用颜色</button>
          </div>
          <div class="settings-row">
            <label>显示节点值:</label>
            <input type="checkbox" id="show-values" checked aria-label="切换节点值显示">
          </div>
        </div>
        <div class="settings-panel">
          <h3>💾 导出设置</h3>
          <div class="settings-row">
            <button class="btn" onclick="exportSettings()" aria-label="导出配置">📤 导出配置</button>
            <button class="btn" onclick="resetSettings()" aria-label="重置设置">🔄 重置设置</button>
          </div>
        </div>
      </div>
    </section>

    <footer>
      <p>© 2025 线段树探索者 | 🌟 让数据结构变得有趣 🌟</p>
    </footer>
  </main>
  <script>
    // 主题切换功能
    function switchTheme(theme) {
      // 更新data-theme属性
      document.documentElement.setAttribute('data-theme', theme);
      
      // 更新按钮状态
      document.querySelectorAll('.theme-option').forEach(btn => {
        btn.classList.remove('active');
      });
      document.querySelector(`[data-theme="${theme}"]`).classList.add('active');
      
      // 保存到localStorage
      localStorage.setItem('theme', theme);
      
      // 更新currentTheme变量
      currentTheme = theme;
    }    // 页面加载时的初始化
    document.addEventListener('DOMContentLoaded', function() {
      // 恢复主题
      const savedTheme = localStorage.getItem('theme') || 'light';
      switchTheme(savedTheme);
      
      // 先应用高亮
      applyHighlighting();
      
      // 然后加载设置
      Settings.load();
      
      // 设置延迟高亮监听
      setupLazyHighlighting();
      
      // 确保字体大小和行高显示元素存在
      if (DOM.fontSizeDisplay) {
        DOM.fontSizeDisplay.textContent = currentFontSize + 'px';
      }
      if (DOM.lineHeightDisplay) {
        DOM.lineHeightDisplay.textContent = currentLineHeight;
      }

      // 导航事件委托
      document.querySelector('nav').addEventListener('click', (e) => {
        if (e.target.tagName === 'BUTTON') {
          const sectionId = e.target.getAttribute('onclick').match(/'([^']+)'/)[1];
          showSection(sectionId);
        }
      });

      // 设置相关事件
      if (DOM.fontSizeSlider) {
        DOM.fontSizeSlider.addEventListener('input', debounce(e => changeFontSize(e.target.value), 100));
      }
      if (DOM.lineHeightSlider) {
        DOM.lineHeightSlider.addEventListener('input', debounce(e => changeLineHeight(e.target.value), 100));
      }
      if (DOM.animationSpeed) {
        DOM.animationSpeed.addEventListener('change', () => {
          animationSpeed = DOM.animationSpeed.value;
          Settings.save();
        });
      }
      if (DOM.showValues) {
        DOM.showValues.addEventListener('change', toggleNodeValues);
      }
      if (DOM.btnBuild && DOM.inputN && DOM.treeContainer) {
        DOM.btnBuild.addEventListener('click', () => {
          const n = parseInt(DOM.inputN.value);
          buildTreeVisualization(n, DOM.treeContainer);
        });
      }
    });

    // 全局变量
    let currentTheme = 'light'; // 改为默认light主题
    let currentFontSize = 14;
    let currentLineHeight = 1.6;
    let animationSpeed = 'fast';
    let nodeColor = '#74b9ff';
    let showValues = true;    // 缓存 DOM 元素
    const DOM = {
      fontSizeSlider: document.getElementById('font-size-slider'),
      fontSizeDisplay: document.getElementById('font-size-display'),
      lineHeightSlider: document.getElementById('line-height-slider'),
      lineHeightDisplay: document.getElementById('line-height-display'),
      animationSpeed: document.getElementById('animation-speed'),
      nodeColor: document.getElementById('node-color'),
      showValues: document.getElementById('show-values'),
      treeContainer: document.getElementById('tree-container'),
      quizResult: document.getElementById('quiz-result'),
      inputN: document.getElementById('input-n'),
      btnBuild: document.getElementById('btn-build')
    };    // 语法高亮规则
    const highlightRules = {
      keywords: ['void', 'int', 'if', 'else', 'for', 'while', 'do', 'return', 'struct', 'class', 'public', 'private', 'protected', 'const', 'static', 'bool', 'char', 'double', 'float', 'long', 'short', 'unsigned', 'signed', 'auto', 'break', 'continue', 'switch', 'case', 'default', 'namespace', 'using', 'include', 'define', 'ifdef', 'ifndef', 'endif', 'typedef', 'sizeof'],
      types: ['Info', 'Node', 'vector', 'string', 'pair', 'map', 'set', 'queue', 'stack', 'priority_queue', 'MAXN'],
      commonVars: ['info', 'lazy', 'tree', 'arr', 'a', 'n', 'l', 'r', 'u', 'mid', 'val', 'pos', 'ql', 'qr', 'res', 'sum', 'lc', 'rc', 'tot', 'pre', 'k'],
      commentSingle: /(\/\/.*?)(\n|$)/g,
      commentMulti: /(\/\*[\s\S]*?\*\/)/g,
      strings: /("(?:[^"\\]|\\.)*")|('(?:[^'\\]|\\.)*')/g,
      numbers: /\b(\d+)\b/g,
      operators: /(<<|>>|<=|>=|==|!=|&&|\|\||[+\-*%=!&|^~<>])/g,
      functions: /\b([a-zA-Z_][a-zA-Z0-9_]*)\s*(?=\()/g,
      brackets: /([(){}\[\]])/g,
      symbols: /([;,.:])/g,
      pointers: /(\*|&)(?=\s*[a-zA-Z_])/g,
      preprocessor: /(#\w+)/g
    };    // C++ 语法高亮函数 - 精细高亮每个语法元素
    function highlightCode(code) {
      // 预处理：保护字符串和注释
      let protectedItems = [];
      let protectedIndex = 0;
      
      function saveItem(content, type) {
        const placeholder = `__PROTECTED_${protectedIndex}__`;
        protectedItems[protectedIndex] = {
          placeholder: placeholder,
          content: `<span class="${type}">${content}</span>`,
          original: content
        };
        protectedIndex++;
        return placeholder;
      }

      // 1. 保护字符串
      code = code.replace(highlightRules.strings, (match) => {
        return saveItem(match, 'string');
      });

      // 2. 保护注释
      code = code.replace(highlightRules.commentSingle, (match, comment, ending) => {
        return saveItem(comment, 'comment') + ending;
      });
      code = code.replace(highlightRules.commentMulti, (match) => {
        return saveItem(match, 'comment');
      });

      // 3. 保护预处理指令
      code = code.replace(highlightRules.preprocessor, (match) => {
        return saveItem(match, 'preprocessor');
      });

      // 精细化token处理 - 逐字符分析
      function tokenizeAndHighlight(text) {
        const tokens = [];
        let current = '';
        let i = 0;

        while (i < text.length) {
          const char = text[i];
          
          // 检查是否是保护的内容
          if (char === '_' && text.substr(i, 12) === '__PROTECTED_') {
            if (current.trim()) {
              tokens.push(...processTextToken(current));
              current = '';
            }
            // 找到保护内容的结束
            const endIndex = text.indexOf('__', i + 12);
            if (endIndex !== -1) {
              tokens.push(text.substring(i, endIndex + 2));
              i = endIndex + 2;
              continue;
            }
          }
          
          // 处理空白字符
          if (/\s/.test(char)) {
            if (current.trim()) {
              tokens.push(...processTextToken(current));
              current = '';
            }
            tokens.push(char);
            i++;
            continue;
          }
          
          // 处理运算符
          if (/[+\-*/%=!<>&|^~]/.test(char)) {
            if (current.trim()) {
              tokens.push(...processTextToken(current));
              current = '';
            }
            
            // 检查多字符运算符
            let operator = char;
            if (i + 1 < text.length) {
              const nextChar = text[i + 1];
              const twoChar = char + nextChar;
              if (['<<', '>>', '<=', '>=', '==', '!=', '&&', '||'].includes(twoChar)) {
                operator = twoChar;
                i++;
              }
            }
            tokens.push(`<span class="operator">${operator}</span>`);
            i++;
            continue;
          }
          
          // 处理括号
          if (/[(){}\[\]]/.test(char)) {
            if (current.trim()) {
              tokens.push(...processTextToken(current));
              current = '';
            }
            tokens.push(`<span class="bracket">${char}</span>`);
            i++;
            continue;
          }
          
          // 处理符号
          if (/[;,.:?]/.test(char)) {
            if (current.trim()) {
              tokens.push(...processTextToken(current));
              current = '';
            }
            tokens.push(`<span class="symbol">${char}</span>`);
            i++;
            continue;
          }
          
          current += char;
          i++;
        }
        
        if (current.trim()) {
          tokens.push(...processTextToken(current));
        }
        
        return tokens.join('');
      }

      function processTextToken(token) {
        const trimmed = token.trim();
        if (!trimmed) return [token];
        
        const leadingSpace = token.match(/^\s*/)[0];
        const trailingSpace = token.match(/\s*$/)[0];
        const result = [];
        
        if (leadingSpace) result.push(leadingSpace);
        
        // 检查关键字
        if (highlightRules.keywords.includes(trimmed)) {
          result.push(`<span class="keyword">${trimmed}</span>`);
        }
        // 检查类型
        else if (highlightRules.types.includes(trimmed)) {
          result.push(`<span class="type">${trimmed}</span>`);
        }
        // 检查数字
        else if (/^\d+$/.test(trimmed)) {
          result.push(`<span class="number">${trimmed}</span>`);
        }
        // 检查函数（后面跟括号）
        else if (/^[a-zA-Z_][a-zA-Z0-9_]*$/.test(trimmed)) {
          // 检查是否是常见变量
          if (highlightRules.commonVars.includes(trimmed)) {
            result.push(`<span class="variable">${trimmed}</span>`);
          } else {
            // 需要检查上下文来判断是否是函数，这里先按标识符处理
            const nextNonSpace = token.replace(/\s+$/, '');
            // 简单启发式：如果看起来像函数名，就当函数处理
            if (['build', 'query', 'update', 'modify', 'push_up', 'push_down', 'insert', 'kth'].includes(trimmed)) {
              result.push(`<span class="function">${trimmed}</span>`);
            } else {
              result.push(`<span class="variable">${trimmed}</span>`);
            }
          }
        }
        // 检查指针符号
        else if (/[*&]/.test(trimmed)) {
          result.push(`<span class="pointer">${trimmed}</span>`);
        }
        else {
          result.push(trimmed);
        }
        
        if (trailingSpace) result.push(trailingSpace);
        return result;
      }

      // 应用精细化高亮
      const highlightedCode = tokenizeAndHighlight(code);
      
      // 恢复保护的内容
      let finalCode = highlightedCode;
      for (let i = protectedItems.length - 1; i >= 0; i--) {
        const item = protectedItems[i];
        finalCode = finalCode.replace(item.placeholder, item.content);
      }

      return `<code>${finalCode}</code>`;
    }// 立即应用语法高亮
    function applyHighlighting() {
      document.querySelectorAll('.code-block').forEach(block => {
        if (!block.dataset.originalCode) {
          // 检查是否有嵌套的 code 标签
          const codeTag = block.querySelector('code');
          if (codeTag) {
            block.dataset.originalCode = codeTag.textContent;
          } else {
            block.dataset.originalCode = block.textContent;
          }
        }
        
        if (!block.dataset.highlighted) {
          // 确保主题类被正确应用
          if (!block.classList.contains('dark') && !block.classList.contains('light') && 
              !block.classList.contains('monokai') && !block.classList.contains('github')) {
            block.classList.add(currentTheme);
          }
          
          // 应用语法高亮
          const highlightedCode = highlightCode(block.dataset.originalCode);
          
          // 检查是否已经有 code 标签包装，如果有就替换内容，否则直接设置
          const existingCodeTag = block.querySelector('code');
          if (existingCodeTag) {
            existingCodeTag.innerHTML = highlightedCode.replace('<code>', '').replace('</code>', '');
          } else {
            block.innerHTML = highlightedCode;
          }
          
          block.dataset.highlighted = true;
        }
      });
    }    // 延迟加载语法高亮（用于动态添加的代码块）
    function setupLazyHighlighting() {
      const observer = new IntersectionObserver((entries) => {
        entries.forEach(entry => {
          if (entry.isIntersecting) {
            const block = entry.target;
            if (!block.dataset.highlighted) {
              // 获取原始代码内容
              let originalCode = block.dataset.originalCode;
              if (!originalCode) {
                const codeTag = block.querySelector('code');
                originalCode = codeTag ? codeTag.textContent : block.textContent;
              }
              
              // 应用语法高亮
              const highlightedCode = highlightCode(originalCode);
              
              // 检查是否已经有 code 标签包装
              const existingCodeTag = block.querySelector('code');
              if (existingCodeTag) {
                existingCodeTag.innerHTML = highlightedCode.replace('<code>', '').replace('</code>', '');
              } else {
                block.innerHTML = highlightedCode;
              }
              
              block.dataset.highlighted = true;
            }
          }
        });
      }, { threshold: 0.1 });

      // 监听新添加的代码块
      const newBlocks = document.querySelectorAll('.code-block:not([data-observed])');
      newBlocks.forEach(block => {
        if (!block.dataset.originalCode) {
          const codeTag = block.querySelector('code');
          if (codeTag) {
            block.dataset.originalCode = codeTag.textContent;
          } else {
            block.dataset.originalCode = block.textContent;
          }
        }
        block.dataset.observed = 'true';
        observer.observe(block);
      });
    }

    // 导航切换
    function showSection(id) {
      document.querySelectorAll('main section').forEach(sec => sec.classList.remove('active'));
      document.querySelectorAll('nav button').forEach(btn => btn.classList.remove('active'));
      const target = document.getElementById(id);
      if (target) {
        target.classList.add('active');
        const targetBtn = document.querySelector(`button[onclick="showSection('${id}')"]`);
        if (targetBtn) targetBtn.classList.add('active');
      }
    }    // 应用设置到代码块（字体大小、行高等）
    function applyCodeBlockSettings() {
      document.querySelectorAll('.code-block').forEach(block => {
        block.style.fontSize = currentFontSize + 'px';
        block.style.lineHeight = currentLineHeight;
        
        // 确保重新应用高亮
        if (block.dataset.originalCode) {
          const highlightedCode = highlightCode(block.dataset.originalCode);
          const existingCodeTag = block.querySelector('code');
          if (existingCodeTag) {
            existingCodeTag.innerHTML = highlightedCode.replace('<code>', '').replace('</code>', '');
          } else {
            block.innerHTML = highlightedCode;
          }
          block.dataset.highlighted = true;
        }
      });
      Settings.save();
    }    // 调整字体大小
    function changeFontSize(size) {
      currentFontSize = parseInt(size);
      DOM.fontSizeDisplay.textContent = size + 'px';
      applyCodeBlockSettings();
    }

    // 调整行高    // 调整行高
    function changeLineHeight(height) {
      currentLineHeight = parseFloat(height);
      DOM.lineHeightDisplay.textContent = height;
      applyCodeBlockSettings();
    }

    // 应用节点颜色
    function applyNodeColor() {
      nodeColor = DOM.nodeColor.value;
      const style = document.createElement('style');
      style.innerHTML = `
        .tree-node { background: ${nodeColor} !important; }
        .tree-node.depth-0 { background: ${nodeColor} !important; }
        .tree-node.depth-1 { background: ${nodeColor} !important; }
        .tree-node.depth-2 { background: ${nodeColor} !important; }
        .tree-node.depth-3 { background: ${nodeColor} !important; }
      `;
      document.head.appendChild(style);
      Settings.save();
    }

    // 切换节点值显示
    function toggleNodeValues() {
      showValues = DOM.showValues.checked;
      document.querySelectorAll('.tree-node').forEach(node => {
        node.style.display = showValues ? 'inline-block' : 'none';
      });
      Settings.save();
    }

    // 获取动画延迟
    function getAnimationDelay() {
      const speeds = { slow: 2000, normal: 1000, fast: 500 };
      return speeds[animationSpeed] || 1000;
    }
    // 线段树可视化 - 基于边界的智能布局算法
    function buildTreeVisualization(n, container) {
      if (n < 1 || n > 8) {
        alert('请输入1-8');
        return;
      }

      container.innerHTML = '<h4>🌲 线段树构建过程:</h4>';
      container.innerHTML += `<p><strong>数组长度:</strong> ${n}</p>`;
      const treeVisual = document.createElement('div');
      treeVisual.className = 'tree-visual';
      treeVisual.style.position = 'relative';
      treeVisual.style.width = '100%';
      treeVisual.style.padding = '25px';
      treeVisual.style.background = 'var(--card-bg)';
      treeVisual.style.borderRadius = '18px';
      treeVisual.style.borderLeft = '5px solid var(--primary-color)';
      treeVisual.style.boxShadow = '0 8px 25px rgba(0, 0, 0, 0.1)';
      treeVisual.style.overflow = 'visible';
      container.appendChild(treeVisual);

      // 获取实际容器宽度，考虑padding
      const containerWidth = treeVisual.clientWidth - 50;
      const nodeMinWidth = 50;
      const levelHeight = 80;
      const padding = 25;

      // 计算实际层数（不是最大理论深度）
      function calculateActualDepth(n) {
        if (n === 1) return 1;
        return Math.floor(Math.log2(n)) + 1;
      }
      
      const actualDepth = calculateActualDepth(n);

      // 首先收集所有层级的节点信息
      const levels = [];
      function collectLevels(l, r, u, depth = 0) {
        if (!levels[depth]) levels[depth] = [];
        levels[depth].push({ l, r, u, depth });
        
        if (l < r) {
          const mid = Math.floor((l + r) / 2);
          collectLevels(l, mid, u * 2, depth + 1);
          collectLevels(mid + 1, r, u * 2 + 1, depth + 1);
        }
      }

      collectLevels(1, n, 1);

      // 动态设置容器高度 - 根据实际层数计算
      const totalLevels = levels.length;
      const baseHeight = 60; // 基础高度
      const calculatedHeight = totalLevels * levelHeight + baseHeight + 40; // 减少额外缓冲
      const minHeight = Math.max(200, calculatedHeight); // 最小高度降低到200px
      treeVisual.style.minHeight = `${minHeight}px`;
      treeVisual.style.height = `${minHeight}px`; // 同时设置固定高度

      // 节点位置信息存储
      const nodePositions = new Map();

      // 计算每个节点的精确位置 - 父子节点宽度继承关系
      function calculateNodePositions(l, r, u, depth = 0, leftBound = 0, rightBound = containerWidth, parentWidth = null) {
        const y = depth * levelHeight + 30;
        
        // 检查是否为最底层（叶子节点层）
        const isLeafLevel = (depth === levels.length - 1);
        const nodesInLevel = levels[depth].length;
        const totalNodesInLevel = Math.pow(2, depth);
        
        let x, nodeWidth;
        
        if (isLeafLevel) {
          // 叶子节点：宽度为父节点的一半，且与父节点边界对齐
          if (parentWidth) {
            nodeWidth = parentWidth / 2;
          } else {
            nodeWidth = Math.max(nodeMinWidth, (containerWidth - 2 * padding) / totalNodesInLevel);
          }
          
          // 判断是左子节点还是右子节点
          const parentU = Math.floor(u / 2);
          const isLeftChild = (u % 2 === 0);
          const parentPos = nodePositions.get(parentU) || { x: containerWidth / 2 };
          
          if (isLeftChild) {
            // 左子节点：基于父节点左半部分的中心
            const leftHalfCenter = parentPos.x - parentWidth / 4;
            x = Math.max(padding + nodeWidth / 2, leftHalfCenter);
          } else {
            // 右子节点：基于父节点右半部分的中心
            const rightHalfCenter = parentPos.x + parentWidth / 4;
            x = Math.min(containerWidth - padding - nodeWidth / 2, rightHalfCenter);
          }
        } else {
          // 非叶子层：铺满整行或均匀分布，确保不超出边界
          if (nodesInLevel === 1) {
            // 只有一个节点时：填满整个可用宽度
            nodeWidth = containerWidth - 2 * padding;
            x = containerWidth / 2;
          } else {
            // 多个节点时：均分可用宽度
            const availableWidth = containerWidth - 2 * padding;
            nodeWidth = availableWidth / nodesInLevel;
            // 确保节点宽度不小于最小值
            nodeWidth = Math.max(nodeWidth, nodeMinWidth);
            
            const nodeIndex = levels[depth].findIndex(node => node.u === u);
            x = padding + nodeWidth * (nodeIndex + 0.5);
          }
        }
        
        nodePositions.set(u, {
          x: x,
          y: y,
          l: l,
          r: r,
          depth: depth,
          nodeWidth: nodeWidth,
          leftBound: leftBound,
          rightBound: rightBound
        });

        if (l < r) {
          const mid = Math.floor((l + r) / 2);
          
          // 为子树分配边界，传递当前节点宽度给子节点
          const boundWidth = (rightBound - leftBound) / 2;
          
          calculateNodePositions(l, mid, u * 2, depth + 1, 
            leftBound, leftBound + boundWidth, nodeWidth);
          calculateNodePositions(mid + 1, r, u * 2 + 1, depth + 1, 
            leftBound + boundWidth, rightBound, nodeWidth);
        }
      }

      // 计算所有节点位置
      calculateNodePositions(1, n, 1, 0, 0, containerWidth, null);
      
      // 边界检查和调整函数，确保所有节点都在容器内
      function ensureBoundaries() {
        nodePositions.forEach((pos, u) => {
          const halfWidth = pos.nodeWidth / 2;
          // 确保节点不超出左边界
          if (pos.x - halfWidth < padding) {
            pos.x = padding + halfWidth;
          }
          // 确保节点不超出右边界
          if (pos.x + halfWidth > containerWidth - padding) {
            pos.x = containerWidth - padding - halfWidth;
          }
        });
      }
      
      ensureBoundaries();

      // 按build递归顺序收集节点
      const buildOrder = [];
      
      function generateBuildOrder(l, r, u, depth = 0) {
        buildOrder.push({ l, r, u, depth });
        
        if (l < r) {
          const mid = Math.floor((l + r) / 2);
          generateBuildOrder(l, mid, u * 2, depth + 1);
          generateBuildOrder(mid + 1, r, u * 2 + 1, depth + 1);
        }
      }

      generateBuildOrder(1, n, 1);

      // 动画渲染
      let orderIndex = 0;
      
      function renderNextNode() {
        if (orderIndex >= buildOrder.length) {
          return;
        }

        const { l, r, u, depth } = buildOrder[orderIndex];
        const position = nodePositions.get(u);
        const nodeInfo = `${u}\n[${l},${r}]`;
        
        // 创建节点元素 - 使用绝对定位
        const nodeDiv = document.createElement('div');
        nodeDiv.className = `tree-node depth-${depth}`;
        nodeDiv.textContent = nodeInfo;
        nodeDiv.setAttribute('data-node-id', u);
        
        // 设置绝对定位和动态宽度
        nodeDiv.style.position = 'absolute';
        nodeDiv.style.left = `${position.x - position.nodeWidth / 2}px`;
        nodeDiv.style.top = `${position.y}px`;
        nodeDiv.style.width = `${position.nodeWidth}px`;
        nodeDiv.style.zIndex = '10';
        
        // 应用自定义颜色
        if (nodeColor !== '#74b9ff') {
          nodeDiv.style.background = nodeColor;
        }
        
        // 初始状态（仅透明度为0，大小已是最终大小）
        nodeDiv.style.opacity = '0';
        nodeDiv.style.transform = 'translateY(-10px)';
        
        treeVisual.appendChild(nodeDiv);
        
        // 添加连接线（如果不是根节点）
        if (depth > 0) {
          addConnectionLine(u, nodePositions);
        }
        
        // 延迟显示动画 - 只改变透明度和位置，不改变大小
        setTimeout(() => {
          nodeDiv.style.transition = 'all 0.4s cubic-bezier(0.4, 0, 0.2, 1)';
          nodeDiv.style.opacity = '1';
          nodeDiv.style.transform = 'translateY(0)';
        }, 50);

        orderIndex++;
        setTimeout(renderNextNode, getAnimationDelay() / 6);
      }

      // 开始渲染
      setTimeout(renderNextNode, 500);
    }

    // 添加父子节点间的连接线
    function addConnectionLine(nodeId, nodePositions) {
      const parentId = Math.floor(nodeId / 2);
      const childPos = nodePositions.get(nodeId);
      const parentPos = nodePositions.get(parentId);
      
      if (!childPos || !parentPos) return;

      const treeVisual = document.querySelector('.tree-visual');
      
      // 创建连接线
      const line = document.createElement('div');
      line.className = 'tree-connection-line';
      line.style.position = 'absolute';
      line.style.background = 'linear-gradient(135deg, var(--primary-color), var(--secondary-color))';
      line.style.zIndex = '5';
      line.style.opacity = '0';
      line.style.borderRadius = '1px';
      
      // 计算连接线的位置和角度
      const deltaX = childPos.x - parentPos.x;
      const deltaY = childPos.y - parentPos.y - 35; // 35是节点高度
      const length = Math.sqrt(deltaX * deltaX + deltaY * deltaY);
      const angle = Math.atan2(deltaY, deltaX) * 180 / Math.PI;
      
      line.style.width = `${length}px`;
      line.style.height = '2px';
      line.style.left = `${parentPos.x}px`;
      line.style.top = `${parentPos.y + 35}px`; // 从父节点底部开始
      line.style.transformOrigin = '0 50%';
      line.style.transform = `rotate(${angle}deg)`;
      
      treeVisual.appendChild(line);
      
      // 延迟显示连接线
      setTimeout(() => {
        line.style.transition = 'opacity 0.4s ease-in-out';
        line.style.opacity = '0.8';
      }, 200);
    }
    // 测试检查
    function checkQuiz() {
      const answers = { q1: 'b', q2: 'c', q3: 'b' };
      let score = 0;
      let results = [];

      for (const [question, correct] of Object.entries(answers)) {
        const selected = document.querySelector(`input[name="${question}"]:checked`);
        if (!selected) {
          results.push(`❌ 问题 ${question.slice(1)}: 未选择答案`);
          continue;
        }
        if (selected.value === correct) {
          score++;
          results.push(`✅ 问题 ${question.slice(1)}: 正确`);
        } else {
          results.push(`❌ 问题 ${question.slice(1)}: 错误`);
        }
      }

      const total = Object.keys(answers).length;
      DOM.quizResult.style.display = 'block';
      DOM.quizResult.innerHTML = `
        <h3>🎯 测试结果</h3>
        <p><strong>得分: ${score}/${total} (${Math.round(score / total * 100)}%)</strong></p>
        ${results.join('<br>')}
        <p style="margin-top: 15px;">
          ${score === total ? '🎉 完美！你已经完全掌握了线段树的基础知识！' :
            score >= total * 0.7 ? '👍 不错！继续加油学习线段树！' :
            '💪 还需要更多练习，建议重新阅读相关内容。'}
        </p>
      `;
      DOM.quizResult.style.background = score === total ? 'var(--success-bg)' :
        score >= total * 0.7 ? 'var(--warning-bg)' : 'var(--error-bg)';
      DOM.quizResult.style.color = 'white';
    }

    // 设置管理
    const Settings = {
      defaults: {
        theme: 'dark',
        fontSize: 14,
        lineHeight: 1.6,
        animationSpeed: 'fast',
        nodeColor: '#74b9ff',
        showValues: true
      },
      save() {
        localStorage.setItem('segmentTreeSettings', JSON.stringify({
          theme: currentTheme,
          fontSize: currentFontSize,
          lineHeight: currentLineHeight,
          animationSpeed: animationSpeed,
          nodeColor: nodeColor,
          showValues: showValues
        }));
      },
      load() {
        const saved = localStorage.getItem('segmentTreeSettings');
        if (saved) {
          Object.assign(this.defaults, JSON.parse(saved));
          currentTheme = this.defaults.theme;
          currentFontSize = this.defaults.fontSize;
          currentLineHeight = this.defaults.lineHeight;
          animationSpeed = this.defaults.animationSpeed;
          nodeColor = this.defaults.nodeColor;
          showValues = this.defaults.showValues;

          DOM.themeSelect.value = currentTheme;
          DOM.fontSizeSlider.value = currentFontSize;
          DOM.lineHeightSlider.value = currentLineHeight;          DOM.animationSpeed.value = animationSpeed;
          DOM.nodeColor.value = nodeColor;
          DOM.showValues.checked = showValues;

          changeFontSize(currentFontSize);
          changeLineHeight(currentLineHeight);
          applyCodeBlockSettings();
        }
        // 无论是否有保存的设置，都应用语法高亮
        setTimeout(() => {
          applyHighlighting();
          setupLazyHighlighting();
        }, 100);
      },
      export() {
        const settings = {
          theme: currentTheme,
          fontSize: currentFontSize,
          lineHeight: currentLineHeight,
          animationSpeed: animationSpeed,
          nodeColor: nodeColor,
          showValues: showValues,
          exportDate: new Date().toISOString()
        };
        dataStr = JSON.stringify(settings, null, 2);
        const dataBlob = new Blob([dataStr], { type: 'application/json' });
        const link = document.createElement('a');
        link.href = URL.createObjectURL(dataBlob);
        link.download = 'segment-tree-settings.json';
        link.click();
      },
      reset() {
        if (confirm('确定要重置所有设置吗？')) {
          localStorage.removeItem('segmentTreeSettings');
          location.reload();
        }
      }
    };

    // 节流函数
    function debounce(func, wait) {
      let timeout;
      return function (...args) {
        clearTimeout(timeout);
        timeout = setTimeout(() => func.apply(this, args), wait);
      };
    }    // 导出和重置设置
    function exportSettings() { Settings.export(); }
    function resetSettings() { Settings.reset(); }
  </script>
</html>