<!DOCTYPE html>
<html lang="zh">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>线段树全方位介绍</title>
  
  <!-- CSS 文件链接 -->
  <link rel="stylesheet" href="styles/main.css">
  <link rel="stylesheet" href="styles/components.css">
  <link rel="stylesheet" href="styles/tree.css">
  <link rel="stylesheet" href="styles/quiz.css">
  <link rel="stylesheet" href="styles/settings.css">
</head>
<body>
  <!-- 三级主题开关 -->
  <div class="theme-switcher">
    <div class="theme-slider"></div> <!-- 新增滑块指示器 -->
    <button class="theme-option active" data-theme="light" onclick="switchTheme('light')" title="白天模式">☀️</button>
    <button class="theme-option" data-theme="eye-care" onclick="switchTheme('eye-care')" title="护眼模式">🌿</button>
    <button class="theme-option" data-theme="dark" onclick="switchTheme('dark')" title="黑夜模式">🌙</button>
  </div>
  <header>🌲 线段树全方位介绍（从入门到入土）</header>

  <nav>
    <button class="nav-btn active" onclick="showSection('intro')" aria-label="线段树简介">📚 线段树简介</button>
    <button class="nav-btn" onclick="showSection('basic')" aria-label="基本操作">🔧 基本操作</button>
    <button class="nav-btn" onclick="showSection('advanced')" aria-label="高级技巧">🚀 高级技巧</button>
    <button class="nav-btn" onclick="showSection('quiz')" aria-label="互动测试">🎯 互动测试</button>
    <button class="nav-btn" onclick="showSection('settings')" aria-label="自定义设置">⚙️ 自定义设置</button>
  </nav>

  <main>
    <section id="intro" class="active">
      <div class="card">
        <h2>🌳 什么是线段树？</h2>
        <p>线段树(Segment Tree)是一个能够高效处理区间查询和更新的数据结构，时间复杂度为<strong>O(log n)</strong>，适用于静态或动态数组。</p>
        <p>它以二叉树的形式递归划分区间，直到每个段表示单个元素，每个节点表示一个区间。</p>
        <h3>📊 线段树可维护的区间信息</h3>
        <p>• <strong>区间和</strong>：计算区间内所有元素的总和</p>
        <p>• <strong>区间最值(RMQ)</strong>：查询区间内的最大值或最小值</p>
        <p>• <strong>区间GCD</strong>：计算区间内所有数的最大公约数</p>
        <p>• <strong>区间最大子段和</strong>：寻找区间内连续子数组的最大和</p>
        <p>• <strong>区间最长连续相同值段</strong>：统计相同值的最长连续长度</p>
        <p>• <strong>区间最长递增/递减段</strong>：寻找最长的单调序列</p>
        <h3>⚡ 线段树支持的区间修改操作</h3>
        <p>• <strong>区间加法</strong>：给区间内所有元素加上某个值</p>
        <p>• <strong>区间乘法</strong>：给区间内所有元素乘以某个值</p>
        <p>• <strong>区间赋值</strong>：将区间内所有元素设为某个值</p>
        <p>• <strong>区间异或</strong>：对区间内所有元素进行异或操作</p>
        <p>• <strong>区间取反</strong>：对区间内所有元素取反</p>
        <p>• <strong>区间拼接</strong>：连接多个区间</p>
      </div>
    </section>

    <section id="basic">
      <div class="card">
        <h2>🔧 线段树的构建与操作</h2>
        <h3>📦 信息与更新结构</h3>
        <p>节点结构：在线段树中，每个节点存储一个区间的信息，这里用 <strong>Info</strong> 结构体来表示，如区间和、最大值、最小值等，
          同时，我们定义了区间合并（<strong>operator+</strong>）与区间更新（<strong>apply</strong>）的方法。</p>
          
        <p>更新结构：为了支持灵活的区间操作，引入了 <strong>Laz</strong> 结构体。它用于存储对某一段区间的修改信息，可作为一种“变更指令”。
          这些修改信息可以传入 <strong>Info</strong> 的 <strong>apply</strong> 方法，按需更新该区间的统计结果。</p>
        <pre class="code-block"><code>struct Laz 
{
    int add = 0;
};

template &lt;typename T&gt;
struct Info 
{
    int sum = 0, mx = 0, mn = 0;
    Info() {}
    Info(T x) : sum(x), mx(x), mn(x) {}
    void apply(const Laz &tag, int len) 
    {
        if (tag.add) 
        {
          mn += tag.add;
          mx += tag.add;
          sum += tag.add * len;
        }
    }

    Info operator+(const Info &a) const 
    {
        Info res;
        res.mn = min(mn, a.mn);
        res.mx = max(mx, a.mx);
        res.sum = sum + a.sum;
        return res;
    }
};
</code></pre>
          
        <h3>📝 构建函数详解</h3>
          <p>线段树的构建通常采用递归的方式，设当前的根节点为 <strong>u</strong>，若当前节点管辖的区间长度已经是 <strong>1</strong>，则可直接根据所需初始化该节点。
            否则我们将该区间对半划分两个子区间，分别进入左右子节点递归建树，最后合并两个子节点的信息（<strong>push_up</strong>）。</p>
        <pre class="code-block" id="build-code"><code>void build(int l, int r, int u)
{
    if (l == r)
    {
        info[u] = Info(arr[l]);
        return;
    }
    
    int mid = (l + r) >> 1;
    build(l, mid, u << 1);
    build(mid + 1, r, u << 1 | 1);
    push_up(u);
}</code></pre>
        <h3>🎯 构建过程可视化</h3>
        <div class="settings-row">
          <label>数组长度 n:</label>
          <input type="number" id="input-n" value="8" min="1" max="8" aria-label="输入数组长度" />
          <button class="btn" id="btn-build" aria-label="开始构建线段树">🚀 开始构建</button>
        </div>
        <div id="tree-container">
          <p>点击"开始构建"按钮查看线段树构建过程</p>
        </div>
        <p>关于线段树的<strong>空间</strong>：通常采用堆式存储（其中节点 <strong>u</strong> 的左儿子为 <strong>2u</strong>，右儿子为 <strong>2u+1</strong>）。
          若有 <strong>n</strong> 个叶子结点，则存储节点的数组范围最大可达 <strong>2<sup>&lceil;log<sub>2</sub>n&rceil;+1</sup></strong>。
          因此，实践中常使用 <strong>4n</strong> 作为数组大小的一个安全上限。</p>

        <h3>📚 其他核心操作</h3>
        <pre class="code-block"><code>// 区间查询
Info query(int l, int r, int ql, int qr, int u)
{
    if (ql <= l && r <= qr)
        return info[u];
    
    int mid = (l + r) >> 1;
    Info res;
    if (ql <= mid)
        res = res + query(l, mid, ql, qr, u << 1);
    if (qr > mid)
        res = res + query(mid + 1, r, ql, qr, u << 1 | 1);
    return res;
}

// 单点更新
void update(int l, int r, int pos, int val, int u)
{
    if (l == r)
    {
        info[u] = Info(val);
        return;
    }
    
    int mid = (l + r) >> 1;
    if (pos <= mid)
        update(l, mid, pos, val, u << 1);
    else
        update(mid + 1, r, pos, val, u << 1 | 1);
    push_up(u);
}</code></pre>
      </div>
    </section>

    <section id="advanced">
      <div class="card">
        <h2>🚀 进阶技巧</h2>
        <h3>⏰ 懒惰标记 (Lazy Propagation)</h3>
        <p>懒惰标记是线段树的重要优化技术，用于处理区间修改操作，避免每次都递归到叶子节点。</p>
        <pre class="code-block"><code>void push_down(int u, int l, int r)
{
    if (lazy[u] != 0)
    {
        int mid = (l + r) >> 1;
        lazy[u << 1] += lazy[u];
        lazy[u << 1 | 1] += lazy[u];
        info[u << 1].sum += lazy[u] * (mid - l + 1);
        info[u << 1 | 1].sum += lazy[u] * (r - mid);
        lazy[u] = 0;
    }
}

// 区间修改
void modify(int l, int r, int ql, int qr, int val, int u)
{
    if (ql <= l && r <= qr)
    {
        lazy[u] += val;
        info[u].sum += val * (r - l + 1);
        return;
    }
    
    push_down(u, l, r);
    int mid = (l + r) >> 1;
    if (ql <= mid)
        modify(l, mid, ql, qr, val, u << 1);
    if (qr > mid)
        modify(mid + 1, r, ql, qr, val, u << 1 | 1);
    push_up(u);
}</code></pre>
        <h3>🌍 可持久化线段树</h3>
        <p>可持久化线段树能够保存数据结构的历史版本，支持查询任意历史时刻的状态。</p>
        <pre class="code-block"><code>struct Node
{
    int sum, lc, rc;
} tree[MAXN];

int tot = 0;

int build(int l, int r)
{
    int u = ++tot;
    if (l == r)
    {
        tree[u].sum = a[l];
        return u;
    }
    
    int mid = (l + r) >> 1;
    tree[u].lc = build(l, mid);
    tree[u].rc = build(mid + 1, r);
    tree[u].sum = tree[tree[u].lc].sum + tree[tree[u].rc].sum;
    return u;
}

int update(int pre, int l, int r, int pos, int val)
{
    int u = ++tot;
    tree[u] = tree[pre];
    if (l == r)
    {
        tree[u].sum += val;
        return u;
    }
    
    int mid = (l + r) >> 1;
    if (pos <= mid)
        tree[u].lc = update(tree[pre].lc, l, mid, pos, val);
    else
        tree[u].rc = update(tree[pre].rc, mid + 1, r, pos, val);
    tree[u].sum = tree[tree[u].lc].sum + tree[tree[u].rc].sum;
    return u;
}</code></pre>
        <h3>⚖️ 权值线段树</h3>
        <p>权值线段树以值域作为下标建树，常用于处理第k小数、数值统计等问题。</p>
        <pre class="code-block"><code>// 插入一个数值
void insert(int l, int r, int val, int u)
{
    tree[u]++;
    if (l == r)
        return;
        
    int mid = (l + r) >> 1;
    if (val <= mid)
        insert(l, mid, val, u << 1);
    else
        insert(mid + 1, r, val, u << 1 | 1);
}

// 查询第k小的数
int kth(int l, int r, int k, int u)
{
    if (l == r)
        return l;
        
    int mid = (l + r) >> 1;
    if (tree[u << 1] >= k)
        return kth(l, mid, k, u << 1);
    else
        return kth(mid + 1, r, k - tree[u << 1], u << 1 | 1);
}</code></pre>
      </div>
    </section>

    <section id="quiz">
      <div class="card">
        <h2>🎯 互动小测</h2>
        <p>通过以下选择题测试你对线段树的理解程度！</p>
        <div id="quiz-container">
          <div class="quiz-question">
            <h3>问题 1: 线段树的单次区间操作的时间复杂度是？</h3>
            <div class="quiz-options">
              <div class="quiz-option-item">
                <input type="radio" name="q1" value="a" id="q1a" aria-label="选项A: O(n)">
                <label for="q1a">A. O(n)</label>
              </div>
              <div class="quiz-option-item">
                <input type="radio" name="q1" value="b" id="q1b" aria-label="选项B: O(log n)">
                <label for="q1b">B. O(log n)</label>
              </div>
              <div class="quiz-option-item">
                <input type="radio" name="q1" value="c" id="q1c" aria-label="选项C: O(n log n)">
                <label for="q1c">C. O(n log n)</label>
              </div>
              <div class="quiz-option-item">
                <input type="radio" name="q1" value="d" id="q1d" aria-label="选项D: O(n²)">
                <label for="q1d">D. O(n²)</label>
              </div>
            </div>
          </div>
          <div class="quiz-question">
            <h3>问题 2: 线段树的空间复杂度通常是？</h3>
            <div class="quiz-options">
              <div class="quiz-option-item">
                <input type="radio" name="q2" value="a" id="q2a" aria-label="选项A: 空间约为输入规模的1倍">
                <label for="q2a">A. 空间约为输入规模的1倍</label>
              </div>
              <div class="quiz-option-item">
                <input type="radio" name="q2" value="b" id="q2b" aria-label="选项B: 空间约为输入规模的2倍">
                <label for="q2b">B. 空间约为输入规模的2倍</label>
              </div>
              <div class="quiz-option-item">
                <input type="radio" name="q2" value="c" id="q2c" aria-label="选项C: 空间约为输入规模的4倍">
                <label for="q2c">C. 空间约为输入规模的4倍</label>
              </div>
              <div class="quiz-option-item">
                <input type="radio" name="q2" value="d" id="q2d" aria-label="选项D: 空间约为输入规模的 n log n 倍">
                <label for="q2d">D. 空间约为输入规模的 n log n 倍</label>
              </div>
            </div>
          </div>
          <div class="quiz-question">
            <h3>问题 3: 懒惰标记的主要作用是？</h3>
            <div class="quiz-options">
              <div class="quiz-option-item">
                <input type="radio" name="q3" value="a" id="q3a" aria-label="选项A: 减少内存使用">
                <label for="q3a">A. 减少内存使用</label>
              </div>
              <div class="quiz-option-item">
                <input type="radio" name="q3" value="b" id="q3b" aria-label="选项B: 优化区间修改操作">
                <label for="q3b">B. 优化区间修改操作</label>
              </div>
              <div class="quiz-option-item">
                <input type="radio" name="q3" value="c" id="q3c" aria-label="选项C: 简化代码实现">
                <label for="q3c">C. 简化代码实现</label>
              </div>
              <div class="quiz-option-item">
                <input type="radio" name="q3" value="d" id="q3d" aria-label="选项D: 提高查询速度">
                <label for="q3d">D. 提高查询速度</label>
              </div>
            </div>
          </div>
          <button class="btn" onclick="checkQuiz()" aria-label="提交测试答案">📊 提交答案</button>
          <div id="quiz-result" class="quiz-result"></div>
        </div>
      </div>
    </section>

    <section id="settings">
      <div class="card">
        <h2>⚙️ 自定义设置</h2>
        <div class="settings-panel">
          <h3>🎨 代码高亮主题</h3>
          <div class="settings-row">
            <label>字体大小:</label>
            <input type="range" id="font-size-slider" min="12" max="20" value="15" aria-label="调整代码字体大小">
            <span id="font-size-display">15px</span>
          </div>
          <div class="settings-row">
            <label>行高:</label>
            <input type="range" id="line-height-slider" min="1.2" max="2.0" step="0.1" value="1.6" aria-label="调整代码行高">
            <span id="line-height-display">1.6</span>
          </div>
        </div>
        <div class="settings-panel">
          <h3>🌲 可视化设置</h3>
          <div class="settings-row">
            <label>动画速度:</label>
            <select id="animation-speed" aria-label="选择动画速度">
              <option value="slow">🐌 慢速 (2秒)</option>
              <option value="normal" selected>🚀 正常 (1秒)</option>
              <option value="fast">⚡ 快速 (0.5秒)</option>
            </select>
          </div>
          <div class="settings-row">
            <label>显示节点值:</label>
            <input type="checkbox" id="show-values" checked aria-label="切换节点值显示">
          </div>
        </div>
        <div class="settings-panel">
          <h3>💾 导出设置</h3>
          <div class="settings-row">
            <button class="btn" onclick="exportSettings()" aria-label="导出配置">📤 导出配置</button>
            <button class="btn" onclick="resetSettings()" aria-label="重置设置">🔄 重置设置</button>
          </div>
        </div>
      </div>
    </section>

    <footer>
      <p>© 2025 线段树探索者 | 🌟 让数据结构变得有趣 🌟</p>
    </footer>
  </main>

  <!-- JavaScript 文件链接 -->
  <script src="js/syntaxHighlighter.js"></script>
  <script src="js/navigation.js"></script>
  <script src="js/treeVisualizer.js"></script>
  <script src="js/quiz.js"></script>
  <script src="js/settings.js"></script>
  <script src="js/main.js"></script>
  <script>
    // Ensure initQuiz is called after the DOM is loaded
    document.addEventListener('DOMContentLoaded', function() {
      if (window.Quiz && typeof window.Quiz.initQuiz === 'function') {
        window.Quiz.initQuiz();
      }
    });
  </script>
</body>
</html>
