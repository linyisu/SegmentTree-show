<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>连线方法对比测试</title>
    <link rel="stylesheet" href="styles/main.css">
    <link rel="stylesheet" href="styles/tree.css">
    <style>
        body {
            padding: 20px;
            background: #f8f9fa;
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
        }
        .comparison-container {
            display: flex;
            gap: 20px;
            margin: 20px 0;
        }
        .method-panel {
            flex: 1;
            border: 2px solid #ddd;
            border-radius: 12px;
            padding: 15px;
            background: white;
        }
        .improved-method {
            border-color: #28a745;
        }
        .original-method {
            border-color: #ffc107;
        }
        .method-title {
            font-weight: bold;
            margin-bottom: 10px;
            padding: 8px 12px;
            border-radius: 6px;
            text-align: center;
        }
        .improved-method .method-title {
            background: #d4edda;
            color: #155724;
        }
        .original-method .method-title {
            background: #fff3cd;
            color: #856404;
        }
        .feature-list {
            font-size: 14px;
            margin: 10px 0;
        }
        .feature-list li {
            margin: 5px 0;
            padding-left: 20px;
            position: relative;
        }
        .feature-list .improved {
            color: #28a745;
        }
        .feature-list .original {
            color: #ffc107;
        }
        .feature-list .improved::before {
            content: "✅";
            position: absolute;
            left: 0;
        }
        .feature-list .original::before {
            content: "⚠️";
            position: absolute;
            left: 0;
        }
        .demo-controls {
            margin: 15px 0;
            text-align: center;
        }
        .demo-controls button {
            margin: 5px;
            padding: 8px 16px;
            border: none;
            border-radius: 6px;
            background: #007bff;
            color: white;
            cursor: pointer;
        }
        .demo-controls button:hover {
            background: #0056b3;
        }
        .tree-visual {
            min-height: 300px;
            border: 1px solid #eee;
            border-radius: 8px;
            margin-top: 10px;
        }
    </style>
</head>
<body>
    <h1>线段树连线方法对比</h1>
    
    <div class="comparison-container">
        <div class="method-panel improved-method">
            <div class="method-title">改进方法 (generate_Visualizer_modify.js)</div>
            <ul class="feature-list">
                <li class="improved">使用 getBoundingClientRect() 获取真实 DOM 边界</li>
                <li class="improved">精确计算父节点底边中点 → 子节点顶边中点</li>
                <li class="improved">自动适应节点尺寸变化</li>
                <li class="improved">resize 时重新计算边界</li>
                <li class="improved">支持不同内容的节点高度</li>
            </ul>
            <div class="demo-controls">
                <button onclick="buildImprovedTree()">构建改进树</button>
                <button onclick="updateImprovedTree()">区间修改</button>
                <button onclick="resizeImprovedContainer()">改变容器大小</button>
            </div>
            <div id="improvedTree" class="tree-visual"></div>
        </div>
        
        <div class="method-panel original-method">
            <div class="method-title">原始方法 (treeVisualizer.js)</div>
            <ul class="feature-list">
                <li class="original">使用硬编码偏移量 (±35px)</li>
                <li class="original">假设所有节点高度相同</li>
                <li class="original">基于计算位置而非实际 DOM</li>
                <li class="original">不能适应内容变化</li>
                <li class="original">连线可能偏移节点边界</li>
            </ul>
            <div class="demo-controls">
                <button onclick="buildOriginalTree()">构建原始树</button>
                <button onclick="highlightOriginalTree()">突出显示</button>
                <button onclick="resizeOriginalContainer()">改变容器大小</button>
            </div>
            <div id="originalTree" class="tree-visual"></div>
        </div>
    </div>

    <div style="background: white; padding: 15px; border-radius: 8px; margin-top: 20px;">
        <h3>技术对比总结</h3>
        <table style="width: 100%; border-collapse: collapse;">
            <tr style="background: #f8f9fa;">
                <th style="padding: 10px; border: 1px solid #ddd;">特性</th>
                <th style="padding: 10px; border: 1px solid #ddd;">原始方法</th>
                <th style="padding: 10px; border: 1px solid #ddd;">改进方法</th>
            </tr>
            <tr>
                <td style="padding: 10px; border: 1px solid #ddd;">连线端点计算</td>
                <td style="padding: 10px; border: 1px solid #ddd;">position.y ± 35px (硬编码)</td>
                <td style="padding: 10px; border: 1px solid #ddd;">getBoundingClientRect() (实际边界)</td>
            </tr>
            <tr>
                <td style="padding: 10px; border: 1px solid #ddd;">节点尺寸适应</td>
                <td style="padding: 10px; border: 1px solid #ddd;">固定假设</td>
                <td style="padding: 10px; border: 1px solid #ddd;">动态检测</td>
            </tr>
            <tr>
                <td style="padding: 10px; border: 1px solid #ddd;">浏览器兼容性</td>
                <td style="padding: 10px; border: 1px solid #ddd;">可能出现偏移</td>
                <td style="padding: 10px; border: 1px solid #ddd;">跨浏览器精确</td>
            </tr>
            <tr>
                <td style="padding: 10px; border: 1px solid #ddd;">维护性</td>
                <td style="padding: 10px; border: 1px solid #ddd;">需要调整硬编码值</td>
                <td style="padding: 10px; border: 1px solid #ddd;">自动适应，无需维护</td>
            </tr>
        </table>
    </div>

    <script src="js/treeVisualizer.js"></script>
    <script src="js/generate_Visualizer_modify.js"></script>
    <script>
        let improvedVisualizer, originalVisualizer;

        function buildImprovedTree() {
            const container = document.getElementById('improvedTree');
            if (improvedVisualizer) {
                improvedVisualizer.clearTree();
            }
            improvedVisualizer = new ModifyTreeVisualizer(container);
            improvedVisualizer.buildTreeFromInput("1,2,3,4,5");
        }

        function updateImprovedTree() {
            if (improvedVisualizer) {
                improvedVisualizer.performRangeUpdate(2, 4, 3);
            }
        }

        function resizeImprovedContainer() {
            const container = document.getElementById('improvedTree');
            const currentWidth = container.style.width;
            const newWidth = currentWidth === '80%' ? '100%' : '80%';
            container.style.width = newWidth;
            container.style.transition = 'width 0.5s ease';
            
            // 触发 resize 事件
            setTimeout(() => {
                window.dispatchEvent(new Event('resize'));
            }, 100);
        }

        function buildOriginalTree() {
            const container = document.getElementById('originalTree');
            if (originalVisualizer) {
                originalVisualizer.clearTree();
            }
            originalVisualizer = new TreeVisualizer(container);
            originalVisualizer.buildTreeFromInput("1,2,3,4,5");
        }

        function highlightOriginalTree() {
            const container = document.getElementById('originalTree');
            const nodes = container.querySelectorAll('.tree-node');
            const lines = container.querySelectorAll('.tree-connection-line');
            
            // 突出显示硬编码偏移的问题
            nodes.forEach(node => {
                node.style.border = '2px solid red';
                node.style.boxShadow = '0 0 5px rgba(255, 0, 0, 0.5)';
            });
            
            lines.forEach(line => {
                line.style.boxShadow = '0 0 3px rgba(255, 165, 0, 0.8)';
                line.style.background = 'orange';
            });
        }

        function resizeOriginalContainer() {
            const container = document.getElementById('originalTree');
            const currentWidth = container.style.width;
            const newWidth = currentWidth === '80%' ? '100%' : '80%';
            container.style.width = newWidth;
            container.style.transition = 'width 0.5s ease';
            
            // 触发 resize 事件
            setTimeout(() => {
                window.dispatchEvent(new Event('resize'));
            }, 100);
        }

        // 页面加载后自动构建两个树进行对比
        window.addEventListener('load', () => {
            setTimeout(() => {
                buildImprovedTree();
                buildOriginalTree();
            }, 500);
        });
    </script>
</body>
</html>
